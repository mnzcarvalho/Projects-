# 🎮 GUIA DE IMPLEMENTAÇÃO - ETERNAL IDLE JAVA + JAVAFX

## 📋 CONTEXTO DO PROJETO

PROJETO: Eternal Idle - Jogo Idle/RPG em Java
ESTADO ATUAL: Lógica completa + Interface console pronta
OBJETIVO: Migrar para JavaFX mantendo toda a lógica existente

## 🏗️ ESTRUTURA ATUAL DO PROJETO

EternalIdle/
├── src/
│   └── main/
│       └── java/
│           ├── eternalidle/           # NOVO PACKAGE JAVAFX
│           │   ├── EternalIdleApp.java
│           │   ├── controller/
│           │   │   └── GameController.java
│           │   └── view/
│           │       └── game.fxml
│           └── EternalIdle/           # PACKAGE ORIGINAL (lógica do jogo)
│               ├── systems/
│               │   ├── GameManager.java      ✅ COMPLETO
│               │   ├── EquipmentManager.java
│               │   ├── DropSystem.java
│               │   ├── ShopSystem.java
│               │   ├── StashSystem.java
│               │   ├── CraftingSystem.java
│               │   └── BossManager.java
│               ├── entity/
│               │   ├── Player.java           ✅ COMPLETO
│               │   ├── Monster.java
│               │   └── MonsterFactory.java
│               ├── items/
│               │   ├── equipment/
│               │   │   ├── Weapon.java
│               │   │   └── Armor.java
│               │   └── consumable/
│               │       └── Potion.java
│               └── inventory/
│                   └── Inventory.java

## 🔧 CONFIGURAÇÃO TÉCNICA

JAVA_VERSION: JDK 23
JAVAFX_VERSION: 17.0.17
CONFIGURAÇÃO: VM Options necessárias
--module-path "D:\javafx-sdk-17.0.17\lib" --add-modules javafx.controls,javafx.fxml,javafx.graphics

## ✅ O QUE JÁ FUNCIONA

1. GameManager.java - Lógica completa do jogo
   - Métodos públicos disponíveis:
     * simulateCombat() - Executa combate manual
     * updateGame() - Atualização automática do jogo
     * getPlayer() - Retorna objeto Player
     * getCurrentMonster() - Retorna monstro atual
     * getMonsterHealthInfo() - String com vida do monstro
     * getCurrentMonsterName() - Nome do monstro
     * openShop(), showInventory(), showSkills(), etc.

2. Player.java - Sistema completo do jogador
   - Métodos para JavaFX:
     * getLevel(), getGold(), getExperience()
     * getExpToNextLevel() - EXP para próximo nível
     * getExpProgress() - Progresso 0.0 a 1.0
     * getCurrentExp() - EXP atual

3. EternalIdleApp.java - Interface JavaFX base
   - Carrega game.fxml
   - Inicializa GameController
   - Loop de atualização de UI funcionando

4. GameController.java - Conexão UI-lógica
   - Properties observáveis para dados do jogo
   - Atualização automática a cada 1 segundo
   - Botões conectados aos métodos do GameManager

## 🎯 PRÓXIMOS PASSOS DE IMPLEMENTAÇÃO

### FASE 1: EXPANDIR INTERFACE PRINCIPAL (2-3 horas)

ARQUIVOS: EternalIdleApp.java, GameController.java, game.fxml

TAREFAS:
1. Adicionar mais componentes visuais em game.fxml:
   - Barra de vida do monstro visual
   - Indicador de tier atual
   - Contador de DPS do jogador
   - Display de defesa total

2. Aprimorar GameController.java:
   - Adicionar bindings para novos componentes
   - Implementar sistema de tooltips
   - Adicionar animações simples

3. Criar CSS básico:
   - Estilizar progress bars
   - Cores por raridade de itens
   - Efeitos hover nos botões

### FASE 2: SISTEMA DE INVENTÁRIO VISUAL (3-4 horas)

ARQUIVOS NOVOS:
- InventoryController.java
- inventory.fxml
- inventory.css

FUNCIONALIDADES:
1. Grid 5x4 de slots de inventário
2. Slots de equipamento separados
3. Drag & drop para equipar itens
4. Tooltips com informações dos itens
5. Diferenciação visual por raridade

CONEXÕES COM SISTEMA EXISTENTE:
- InventoryController usará gameManager.getPlayer().getInventory()
- InventoryController usará gameManager.getPlayer().getEquipmentManager()

### FASE 3: ÁRVORE DE HABILIDADES INTERATIVA (3-4 horas)

ARQUIVOS NOVOS:
- SkillsController.java
- skills.fxml
- skills.css

FUNCIONALIDADES:
1. Representação visual da árvore de skills
2. Nós clicáveis com conexões visuais
3. Sistema de pontos de habilidade
4. Preview de habilidades antes de comprar
5. Diferentes cores por tipo de habilidade

CONEXÕES:
- SkillsController usará gameManager.getPlayer().getSkillTree()

### FASE 4: SISTEMA DE LOJA VISUAL (2-3 horas)

ARQUIVOS NOVOS:
- ShopController.java
- shop.fxml
- shop.css

FUNCIONALIDADES:
1. Abas por categorias (Armas, Armaduras, Consumíveis)
2. Lista de itens disponíveis para compra
3. Sistema de compra com confirmação
4. Indicador de ouro disponível
5. Filtros por nível e raridade

CONEXÕES:
- ShopController usará gameManager.openShop()

### FASE 5: SISTEMA DE CRAFTING VISUAL (3-4 horas)

ARQUIVOS NOVOS:
- CraftingController.java
- crafting.fxml
- crafting.css

FUNCIONALIDADES:
1. Grid de receitas disponíveis
2. Sistema de arrastar materiais
3. Preview do item a ser criado
4. Requisitos de nível e materiais
5. Animações de crafting

CONEXÕES:
- CraftingController usará gameManager.openCrafting()

### FASE 6: SISTEMA DE BOSSES VISUAL (2-3 horas)

ARQUIVOS NOVOS:
- BossController.java
- bosses.fxml
- bosses.css

FUNCIONALIDADES:
1. Lista de bosses disponíveis
2. Barra de vida especial para bosses
3. Mecânicas visuais únicas
4. Recompensas preview
5. Sistema de desafio

CONEXÕES:
- BossController usará gameManager.showBosses()

## 🔗 MÉTODOS CHAVE PARA INTEGRAÇÃO

### GameManager - Métodos Públicos Disponíveis:
- simulateCombat(): void - Executa rodada de combate
- updateGame(): void - Atualiza estado do jogo
- getPlayer(): Player - Retorna jogador atual
- getCurrentMonster(): Monster - Retorna monstro atual
- getMonstersDefeated(): int - Contador de monstros
- openShop(): void - Abre sistema de loja
- openStash(): void - Abre stash
- openCrafting(): void - Abre crafting
- showBosses(): void - Mostra bosses
- showSkills(): void - Mostra habilidades
- showInventory(): void - Mostra inventário
- showEquipment(): void - Mostra equipamento
- saveGame(String): void - Salva jogo

### Player - Métodos para UI:
- getLevel(): int
- getGold(): long
- getExperience(): long
- getExpToNextLevel(): int
- getExpProgress(): double (0.0-1.0)
- getCurrentExp(): long
- getEquipmentManager(): EquipmentManager
- getSkillTree(): SkillTree
- getAttributes(): PlayerAttributes

## 🎨 DIRETRIZES DE IMPLEMENTAÇÃO

### Padrão para Novos Controllers:
```java
package eternalidle.controller;

import EternalIdle.model.systems.GameManager;
import javafx.fxml.FXML;
import javafx.scene.control.Label;

public class NomeController {
    @FXML private Label algumComponente;
    private GameManager gameManager;

    public void setGameManager(GameManager gameManager) {
        this.gameManager = gameManager;
        initializeData();
    }

    private void initializeData() {
        // Conectar com dados do GameManager
    }
}
Estrutura FXML Básica:
xml
<?xml version="1.0" encoding="UTF-8"?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<VBox xmlns="http://javafx.com/javafx/11.0.1"
      xmlns:fx="http://javafx.com/fxml/1"
      fx:controller="eternalidle.controller.NomeController">
    <!-- Conteúdo da interface -->
</VBox>
CSS Básico:
css
.root {
    -fx-dark-bg: #1e1e1e;
    -fx-darker-bg: #141414;
    -fx-accent: #3498db;
}

.button {
    -fx-background-color: -fx-accent;
    -fx-text-fill: white;
    -fx-background-radius: 5;
}
⚠️ PONTOS DE ATENÇÃO
SEM POM.XML: Configurar JavaFX via VM Options no IDE

CONCORRÊNCIA: Usar Platform.runLater() para atualizações de UI

PERFORMANCE: Atualizações incrementais, não recarregar tudo

MEMÓRIA: Fechar controllers quando não usados

EXCEÇÕES: Try-catch em todos os métodos que acessam GameManager

🚀 COMEÇAR POR:
FASE 1: Expandir interface principal existente

FASE 2: Implementar inventário visual (mais crítico)

FASE 3: Árvore de habilidades (mais complexo)

📞 INFORMAÇÕES PARA NOVAS CONSULTAS
Ao continuar o desenvolvimento, informar:

"Estou continuando o Eternal Idle JavaFX"

"Estado atual: [descrever o que foi implementado]"

"Preciso implementar: [funcionalidade específica]"

"Problema encontrado: [se houver]"

Isso garantirá continuidade no desenvolvimento!